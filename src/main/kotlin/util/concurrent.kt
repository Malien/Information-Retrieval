package util

import java.util.concurrent.atomic.AtomicInteger
import kotlin.concurrent.thread

/**
 * A wrapper that holds possible future value
 */
class Future<T : Any>(private val getter: () -> T) {
    var value: T? = null
        private set
    var done = false
        private set

    /**
     * Retrieves the value. If it is not yet present, values is generated by the getter func
     */
    fun get(): T = if (done) value!! else {
        value = getter()
        done = true
        value!!
    }
}

val taskCount = AtomicInteger()

/**
 * Launches separate thread of execution, that is expected to return value. That values is returned as a future
 * @param block closure to be run on a separate thread
 * @return Future to the return value of the thread
 */
fun <R : Any> async(block: () -> R): Future<R> {
    var returnValue: R? = null
    val executor = thread(name = "Async-${taskCount.getAndIncrement()}") {
        returnValue = block()
    }
    return Future {
        executor.join()
        returnValue!!
    }
}
